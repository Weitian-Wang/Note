- [Introduction](#introduction)
  - [Focus of the course](#focus-of-the-course)
  - [Abstract Data Type vs Data Structure](#abstract-data-type-vs-data-structure)
    - [Abstract Data Type](#abstract-data-type)
    - [Data Structure](#data-structure)
    - [Examples](#examples)
- [Analysis of Data Structures](#analysis-of-data-structures)
  - [Worst-case](#worst-case)
  - [Average-case](#average-case)
  - [Amortized Analysis](#amortized-analysis)
    - [Amortized Analysis with Potential Function Method](#amortized-analysis-with-potential-function-method)
- [Array](#array)
  - [Abstract Data Type](#abstract-data-type-1)
    - [Data](#data)
    - [Operations](#operations)
- [Array List - Dynamic Arrays](#array-list---dynamic-arrays)
  - [Abstract Data Type](#abstract-data-type-2)
    - [Data](#data-1)
    - [Operations](#operations-1)
- [Stack](#stack)
  - [Abstract Data Type](#abstract-data-type-3)
    - [Data](#data-2)
    - [Operations](#operations-2)
- [FIFO Queue](#fifo-queue)
  - [Abstract Data Type](#abstract-data-type-4)
    - [Data](#data-3)
    - [Operations](#operations-3)
- [Deque - Double-Ended Queue](#deque---double-ended-queue)
  - [Abstract Data Type](#abstract-data-type-5)
    - [Data](#data-4)
    - [Operations](#operations-4)
- [Hash Table](#hash-table)
- [Priority Queue](#priority-queue)
- [Sets](#sets)
- [Binary Search Tree](#binary-search-tree)
- [Search](#search)
- [Tries](#tries)


# Introduction
## Focus of the course
Anlyze the performance of the algorithm implemented with given data structure.  
## Abstract Data Type vs Data Structure
### Abstract Data Type
Abstract data type defines the **logical** form of the data type. We care about the data type and operations about ADT.
### Data Structure
The data structure implements the **physical** form of the data type.  
### Examples
Dictionary
Abstract Data Type:  
- Data type: key/value pairs  
- Operations: 
  - Query: find value associated with a given key
  - Update: store value of a given key  

Data Structure:  
The actual implementation of the ADT above:  
- Hashing schemes
- Balanced binary search trees

# Analysis of Data Structures
## Worst-case
Restrictive time used for real-time response time analysis.
## Average-case
Expected time value, taking input probilities in to account. As we are making assumption about the probilities, average-case time can be inaccurate.
## Amortized Analysis
**Worst** case time for a **sequence** of operations.  
$$\text{Total Actual Time} \leq \text{Total Amortized Time}$$
Worst-case amortized time is the upper bound of worst-case actual time. [Proof see note 2-15](https://www.ics.uci.edu/~dillenco/compsci261p/notes/notes2-handout.pdf).  
### Amortized Analysis with Potential Function Method
1. Define a non-negative potential function $\Phi$, describing the states of the data structure. Initially $\Phi=0$
> Think potential function as the distance between current state of the data structure and the idea state. One analogy would be the gravitational potential energe.  

2. Define amortized time of an operation:
$$\text{amortized time} = \text{actual time} + C\times(\Phi_{new}-\Phi_{old})$$
> The amortized time equals actual time plus change of potential. If change of potential is positive, the data structure is further from its idea state, which is going to cost more time for future operations.  

> The potential is 0 when the data structure is initialized.  
> The potential of the data structure is non-negative(zero or positive).    
> The change of potential $\Delta\Phi=\Phi_{new}-\Phi{old}$ may be negative.
> The actual time of an operation is always positive.
> The amortized time of an operation may be negative, which will make it O(1).

# Array
## Abstract Data Type
### Data
Contiguous store of data items, with fixed length
### Operations
1. Create array of length n, 0-indexed by convention
2. Store a given value at a given index
3. Retrieve value stored at a given idex

# Array List - Dynamic Arrays
## Abstract Data Type
### Data
Continuous store of data items, with variable length. Combines the functionalities of arrays and linked lists.
### Operations
1. Create a new ArrayList of length n
2. Return length of the current ArrayList
3. Store an item in given location index i
4. Reterieve the item stored in location index i
5. Increase the current length by 1
6. Decrease the current length by 1

# Stack
## Abstract Data Type
### Data
Contiguous store of data items, with variable length and FILO/LIFO properties.
### Operations
1. Create an empty stack
2. Push: insert an item at the top of the stack
3. Pop: remove the item at the top of the stack

# FIFO Queue
## Abstract Data Type
### Data
Contiguous store of data items, with variable length and FIFO properties.
### Operations
1. Create an empty queue
2. Enqueue: insert an item at the rear of the queue
3. Dequeue: Remove the item at the front of the queue

# Deque - Double-Ended Queue
## Abstract Data Type
### Data
Contiguous store of data items, with combined functionality of stack and queue.
### Operations
1. Create and empty deque
2. Insert an item at the front of the deque
3. Insert an item at the rear of the deque
4. Remove an item at the front of the deque
5. Remove an item at the rear of the deque


# Hash Table

# Priority Queue

# Sets

# Binary Search Tree

# Search

# Tries
